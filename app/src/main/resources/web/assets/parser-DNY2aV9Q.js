const i=({string:a,part:t})=>{const r=a.split(`
`).filter(o=>o.includes(t));if(!r.length)return;const n=r.map(o=>{var p,d;return(d=(p=o.match(new RegExp("((?<==).)(.+$)","gm")))==null?void 0:p[0])==null?void 0:d.trim()}).filter(o=>o!==void 0);if(n.length)return n},J=a=>{const t=[],{wgInterface:v,peers:r}=a,{address:n,privateKey:o,listenPort:p,name:d,dns:f,mtu:m,table:h,preUp:g,postUp:l,preDown:u,postDown:c}=v;return t.push("[Interface]"),d!==void 0&&t.push(`#app:Name = ${d}`),n!==void 0&&n.length&&t.push(`Address = ${n.join(",")}`),o&&t.push(`PrivateKey = ${o}`),p&&t.push(`ListenPort = ${p}`),f&&f.length&&t.push(`DNS = ${f.join(",")}`),m&&t.push(`MTU = ${m}`),h&&t.push(`Table = ${h}`),g&&g.length&&t.push(g.map(e=>`PreUp = ${e}`).join(`
`)),l&&l.length&&t.push(l.map(e=>`PostUp = ${e}`).join(`
`)),u&&u.length&&t.push(u.map(e=>`PreDown = ${e}`).join(`
`)),c&&c.length&&t.push(c.map(e=>`PostDown = ${e}`).join(`
`)),r!=null&&r.length&&r.forEach(e=>{t.push(""),t.push("[Peer]"),e.name&&t.push(`#app:Name = ${e.name}`),e.privateKey&&t.push(`#app:PrivateKey = ${e.privateKey}`),e.publicKey&&t.push(`PublicKey = ${e.publicKey}`),e.allowedIps&&e.allowedIps.length&&t.push(`AllowedIPs = ${e.allowedIps.join(",")}`),e.endpoint&&t.push(`Endpoint = ${e.endpoint}`),e.preSharedKey&&t.push(`PresharedKey = ${e.preSharedKey}`),e.persistentKeepalive&&t.push(`PersistentKeepalive = ${e.persistentKeepalive}`)}),t.join(`
`)},O=a=>{var $,I,b,N,U,D,j,_,A;const t=/\[Interface\][^\[]*/gm,v=/\[Peer\][^\[]*/gm,r=a.match(t),n=r==null?void 0:r[0];if(!n)throw{code:"no_valid_interface",message:`No interface found in config:
${a}`};const o=(I=($=i({string:n,part:"Address"}))==null?void 0:$[0])==null?void 0:I.split(","),p=o?o.filter(s=>s!==void 0):void 0;if(!p||!p.length)throw{code:"no_valid_interface",message:`No address found in config:
${a}`};const d=(b=i({string:n,part:"PrivateKey"}))==null?void 0:b[0];if(!d)throw{code:"no_valid_interface",message:`No privateKey found in config:
${a}`};const f=(N=i({string:n,part:"ListenPort"}))==null?void 0:N[0],m=f?parseInt(f):void 0,h=(U=i({string:n,part:"MTU"}))==null?void 0:U[0],g=h?parseInt(h):void 0,l=(j=(D=i({string:n,part:"DNS"}))==null?void 0:D[0])==null?void 0:j.split(",").filter(s=>s!==void 0),u=l!=null&&l.length?l:void 0,c={address:p,privateKey:d,dns:u,listenPort:m,mtu:g,name:(_=i({string:n,part:"app:Name"}))==null?void 0:_[0],table:(A=i({string:n,part:"Table"}))==null?void 0:A[0],preUp:i({string:n,part:"PreUp"}),postUp:i({string:n,part:"PostUp"}),preDown:i({string:n,part:"PreDown"}),postDown:i({string:n,part:"PostDown"})};let e;for(e in c)c[e]===void 0&&delete c[e];const w=a.match(v),z=w?w.map(s=>{var L,M,C,R,V,k,F,q;if(!s)return;const S=(M=(L=i({string:s,part:"AllowedIPs"}))==null?void 0:L[0])==null?void 0:M.split(","),K=S?S.filter(G=>G!==void 0):void 0;if(!K||!K.length)throw{code:"invalid_peer",message:`No allowedIps found in peer:
${s}`};const T=(C=i({string:s,part:"PublicKey"}))==null?void 0:C[0];if(!T)throw{code:"invalid_peer",message:`No publicKey found in peer:
${s}`};const E=(R=i({string:n,part:"PersistentKeepalive"}))==null?void 0:R[0],B=E?parseInt(E):void 0,P={allowedIps:K,publicKey:T,persistentKeepalive:B,name:(V=i({string:s,part:"app:Name"}))==null?void 0:V[0],privateKey:(k=i({string:s,part:"app:PrivateKey"}))==null?void 0:k[0],endpoint:(F=i({string:s,part:"Endpoint"}))==null?void 0:F[0],preSharedKey:(q=i({string:s,part:"PresharedKey"}))==null?void 0:q[0]};let y;for(y in P)P[y]===void 0&&delete P[y];return P}).filter(s=>s!==void 0):[];return{wgInterface:c,peers:z}};export{J as g,O as p};
